% Created 2018-10-05 Fri 08:52
% Intended LaTeX compiler: pdflatex
\documentclass[bigger]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usetheme{default}
\author{Roger Gordon}
\date{\textit{<2018-09-14 Fri>}}
\title{From DDT to BDD}
\hypersetup{
 pdfauthor={Roger Gordon},
 pdftitle={From DDT to BDD},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.1.13)}, 
 pdflang={English}}
\begin{document}

\maketitle
\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Testing, TDD and DDT}
\label{sec:org5d9994c}
\begin{frame}[label={sec:org68e24c4}]{Testing code is good!}
\begin{block}{Benefits of testing}
As developers, we all know that writing tests is important.
\begin{itemize}
\item Prevents logic errors
\item Helps with refactoring
\item Helps with what to work on
\item Helps to document the system
\item Seems slow, but increases long term development speed
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgf062f6c}]{TDD is even better!}
\begin{block}{Benefits}
\begin{itemize}
\item Ensures we don't write code we don't need
\item Ensures we are sure about the requirements
\item Necessarily ensures our test coverage is 100\%
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org40c3874}]{DDT}
\begin{block}{Is our coverage 100\%?}
If TDD ensures 100\% code coverage, and we practice TDD, why don't we have 100\% code coverage?
\end{block}
\begin{block}{We don't really practice TDD}
TDD is great in theory, but has a hidden assumption
\begin{itemize}
\item \emph{You know exactly what you should do before you start working.}
\item Questions about requirements often come up as we are developing.
\item In this situation TDD is slow and frustrating, because you need to redo both your code and your tests multiple times.
\item We end up practicing \alert{DDT (Development Driven Tests)}
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org7dffd46}]{DDT becomes our standard}
\begin{block}{Habits}
As developers we have a lot of stuff going on in our heads at any one time.
As humans, we instinctively find ways to reduce the amount of mental work we need to do through habits.
Once something works, we keep doing it unless there's a good reason to change.
\begin{itemize}
\item Once we start DDT, it becomes a habit.
\item Even if we could use TDD in a certain case, we implement DDT out of habit.
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgebe628d}]{DDT works!}
\begin{block}{We are doing well already}
\begin{itemize}
\item Our code is generally robust
\item Our test coverage is high
\item We have a good amount of tests
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgdeb28e8}]{DDT works (sometimes).}
\begin{block}{We guess about functionality}
\begin{itemize}
\item We make guesses about how our code should work, based on how we understand the requirements.
\item We sometimes get it wrong.
\item If the requirements change, we need to remember to update our tests and code.
\end{itemize}
\end{block}
\begin{block}{Our tests do not clearly document system behaviour}
\begin{itemize}
\item Only developers can read our tests easily.
\item Our tests make many implicit assumptions. The reason for these assumptions is not always clear.
\item Eg:\href{file:///Users/rogergordon/ownCloud/Documents/Career/Design\_Development/Clients/Tangent\_Solutions/Vumatel/orderfulfilmentservice/orders/ae/tests/test\_order.py}{Example of hard to understand test}
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org8b0ab9b}]{DDT works (sometimes) continued [2]\ldots{}}
\begin{block}{Our coverage numbers are deceptive}
\begin{itemize}
\item We may have a test that calls the code, but that doesn't mean it is a useful test.
\item The assumptions behind a particular test may never be true.
\end{itemize}
\end{block}
\begin{block}{We lose track of what we're doing}
Have you ever been working on something and then something else higher priority got your attention? Do you always remember what you were doing previously? How about on Monday morning? How about after leave?
\end{block}
\end{frame}
\begin{frame}[label={sec:org7960800}]{DDT works (sometimes) continued [3]\ldots{}}
\begin{block}{Business and development are disconnected}
\begin{itemize}
\item Developers speak code
\item Business speaks requirements
\item In general, Business can't read code to check it meets requirements
\item Often, development doesn't understand requirements properly
\end{itemize}
We end up writing code that's not actually needed, and leave out bits that are required.
\end{block}
\end{frame}
\section{BDD to the Rescue}
\label{sec:orge39e762}
\begin{frame}[label={sec:orge723125}]{There is a better way!}
\begin{block}{Behaviour Driven Development (BDD)}
\begin{block}{History}
\begin{itemize}
\item A spin off of TDD, developed in around 2009 by Dan North
\item Resulted in the development of the first BDD testing software, JBehave, for Java
\end{itemize}
\end{block}
\begin{block}{How it works}
\begin{itemize}
\item Uses a plain text business language called "Gherkin" to define requirements. Example:\href{calculator/arithmetic/features/arithmetic.feature}{Example feature file}
\item This language can be read by business, developers and software
\item Software maps the language to automated tests. Example \href{possible\_solution/tests.py}{Example tests}
\end{itemize}
\end{block}
\end{block}
\end{frame}
\begin{frame}[label={sec:org7d57db9}]{BDD Benefits}
BDD makes TDD possible. All the TDD benefits now become available to us.
As a reminder, here they are again:
\begin{itemize}
\item Ensures we don't write code we don't need
\item Ensures we are sure about the requirements
\item Necessarily ensures our test coverage is 100\%
\end{itemize}
Also, we now have a \alert{direct connection between the requirements and our code}. This ensures that business and development stay more closely aligned.
\end{frame}
\begin{frame}[label={sec:org8c2ce11}]{BDD Fixes our DDT problems [1]}
\begin{block}{We \alert{no longer} guess about functionality}
\begin{itemize}
\item We know exactly what we should do because we have the requirements in front of us.
\item Our framework ensures that we don't forget to implement any of the requirements.
\item If the requirements change, our tests will fail and we'll know we need to fix them.
\end{itemize}
\end{block}
\begin{block}{Our tests \alert{do not need to} document system behaviour}
\begin{itemize}
\item Our feature file does this for us instead
\item However, our tests are smaller and are therefore easier to understand.
\item Eg:\href{file:///Users/rogergordon/ownCloud/Documents/Career/Design\_Development/Clients/Tangent\_Solutions/Vumatel/orderfulfilmentservice/orders/ae/tests/test\_order.py}{Example of hard to understand test} vs \href{possible\_solution/tests.py}{Short step test}
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org9346031}]{BDD Fixes our DDT problems [2]}
\begin{block}{Our coverage numbers are \alert{no longer} deceptive}
\begin{itemize}
\item Our code reflects our tests and our coverage is 100\% relevant to the requirements.
\end{itemize}
\end{block}
\begin{block}{We \alert{never need to} lose track of what we're doing \alert{again}}
\begin{itemize}
\item Simply run your tests and whatever doesn't pass is what you need to work on next.
\item Interruptions no longer need to stress us out.
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgef8df59}]{BDD Fixes our DDT problems [3]}
\begin{block}{Business and development are \alert{never} disconnected}
\begin{itemize}
\item Developers speak \sout{code} specifications in feature files.
\item Business speaks \sout{requirements} specifications in feature files.
\item Now we can understand each other unambiguously.
\end{itemize}
We end up writing code that's \sout{not} actually needed, and \alert{never} leave out bits that are required.
\end{block}
\end{frame}
\section{BDD Examples with Morelia}
\label{sec:org738f921}
\begin{frame}[fragile,label={sec:orgcc16040}]{Example: calculator.feature Feature section}
 \begin{itemize}
\item Describes the feature
\item There should be one of these per feature file.
\item Does not map to any tests
\end{itemize}
\scriptsize
\begin{verbatim}
Feature: Performing basic arithmetic operations

    In order to perform basic arithmetic
    As a person who is bad at maths
    I want to be able to provide 2 numbers
    and an operator and get a result back.
\end{verbatim}
\end{frame}

\begin{frame}[fragile,label={sec:org814e783}]{Example: calculator.feature Background section}
 \begin{itemize}
\item For repeated assumptions relevant to all your scenarios
\item One per file
\item Runs before each scenario
\end{itemize}
\scriptsize
\begin{verbatim}
Background:

    Given that we will not use numbers greater
    than 4 digits
        And that we will enter the input in the
        order number1, number2, operator
    When we send a request to the calculator
    Then the response will start with "Result = "
        And the response will end with a number

\end{verbatim}
\end{frame}

\begin{frame}[fragile,label={sec:orgcc4fe32}]{Example: calculator.feature Scenario section}
 \begin{itemize}
\item Many per file encouraged eg: \href{calculator/arithmetic/features/arithmetic.feature}{API endpoint feature file}
\end{itemize}

\scriptsize
\begin{verbatim}
Scenario: Adding 2 numbers

    Given we use the "add" operator for our operations
        And our first number is <number1>
        And our second number is <number2>
    When we call the calculator with our numbers and
    operator
    Then the calculator will return the value <result>

        | number1 | number2 | result |

        |    1    |    1    |   2    |
        |    1    |    2    |   3    |
        |    1    |    3    |   4    |
        |    1    |    6    |   4    |
\end{verbatim}
\end{frame}

\begin{frame}[label={sec:orgb4fd5e7}]{Supporting Software}
\begin{block}{Java}
\begin{itemize}
\item Original BDD framework was written for Java
\item Most well known version is \href{https:cucumber.io}{Cucumber}
\end{itemize}
\end{block}
\begin{block}{Python}
\begin{itemize}
\item Lettuce
\item Behave
\item Morelia
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile,label={sec:org9412043}]{Using Morelia}
 \begin{block}{Installation}
\begin{verbatim}
pip install morelia
\end{verbatim}
\end{block}
\begin{block}{Connecting our feature files to our tests}
\scriptsize
\begin{verbatim}
def test_basic_arithmetic(self):
    """Run tests for the requirements in calculator.feature """
    run('arithmetic/features/arithmetic.feature', self, verbose=True)
\end{verbatim}
\end{block}
\end{frame}
\end{document}
